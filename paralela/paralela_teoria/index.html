<!DOCTYPE HTML>
<!--
	Prism by TEMPLATED
	templated.co @templatedco
	Released for free under the Creative Commons Attribution 3.0 license (templated.co/license)
-->
<html>
	<head>
		<title>Programación Paralela</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<!--[if lte IE 8]><script src="assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="assets/css/main.css" />
		<!--[if lte IE 9]><link rel="stylesheet" href="assets/css/ie9.css" /><![endif]-->
	</head>
	<body>

		<!-- Banner -->
			<section id="banner">
				<div class="inner split">
					<section>
						<h2>Programación Paralela</h2>
					</section>
					
				</div>
			</section>
			
			
		<!-- One -->
			<section id="one" class="wrapper">
				<div class="inner split">
					<section>
						<h3 id="indice" class="anchor" href="#indice" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Índice</h3>
							<ol>
								<li><a href="#two">Introducción/Filosofía</a></li>
								<li><a href="#three">Historia</a></li>
								<li><a href="#four">Ventajas y desventajas</a></li>
								<li><a href="#five">Conceptos clave</a></li>
								<li><a href="#six">Taxonomía de Flynn</a></li>
								<li><a href="#seven">Arquitectura</a></li>
								<li><a href="#eight">Sincronización</a></li>
								<li><a href="#nine">Balanceador de carga</a></li>
								<li><a href="#ten">OpenMP</a></li>
								<li><a href="#eleven">Presentación y taller</a></li>
								<li><a href="#twelve">Bibliografía</a></li>
							</ol>
					</section>					
				</div>
			</section>

		<!-- Two -->
			<section id="two" class="wrapper style2 alt">
				
				<div class="inner split">
					<section>
						<h2>Introducción</h2>
							<p>La computación paralela es el uso de múltiples recursos computacionales para resolver un problema. 
								Se distingue de la computación secuencial en que varias operaciones pueden ocurrir simultáneamente.</p>
							<p>El paralelismo clásico, o puesto de otra manera, el clásico uso del paralelismo, es el de diseño de programas
							 eficientes en el ámbito científico. La simulación de problemas científicos es un área de gran importancia, 
							 los cuales requieren de una gran capacidad de procesamiento y de espacio de memoria, debido a las complejas operaciones 
							 que se deben realizar.</p>
							<p>Otro uso clásico es el de las gráficas generadas por computadora. La generación de fotogramas requiere de una 
							gran cantidad de cálculos matemáticos. Esto supone una tarea muy compleja para un solo procesador, 
							 luego es necesario que haya algún tipo de paralelismo, para distribuir la tarea para que esta sea realizada eficiente y 
							 eficazmente.							
							</p>
						
					</section>
					<section>
						<h2>Filosofía</h2>
						<h3>¿Que es computación paralela?</h3>
						<ul class="checklist">
							<p>En el sentido más simple, la computación paralela es el uso simultáneo de múltiples recursos computacionales para resolver un problema computacional:
							</p>
							<li>Un problema se divide en partes discretas que se pueden resolver simultáneamente</li>
							<li>Cada parte se descompone en una serie de instrucciones</li>
							<li>Las instrucciones de cada parte se ejecutan simultáneamente en diferentes procesadores</li>
							<li>Se emplea un mecanismo global de control/coordinación</li>
						</ul>
					</section>
				</div>
			</section>

		


		<!-- Three -->
			<section id="three" class="wrapper">
				<div class="inner">	
					
						<section>
							<h2>Historia</h2>
							<ul>
								<li>El interés por la computación paralela se remonta a finales de los años 50. Este interés se vio expresado en forma de supercomputadores, que aparecieron en los años 60 y 70. Estos computadores tenían procesadores de memoria compartida, con múltiples procesadores trabajando lado a lado con datos compartidos.</li>
								<li>A mediados de los 80, un nuevo tipo de computador paralelo fue creado cuando el proyecto “Concurrent Computation” de Caltech construyó un supercomputador para aplicaciones científicas. El sistema mostró que se podría lograr un rendimiento extremo usando microprocesadores regulares, disponibles en el mercado.</li>
								<li>Empezando a los finales de los 80, los clusters surgieron para competir y con los MPP. Un cluster es un tipo de computador paralelo, construido usando múltiples computadores “off-the-shelf”, conectados usando una red “off-the-shelf”. Hoy en día, los clusters son la arquitectura dominante en los datacenters.</li>
								<li>Para los MPP y clusters surgió el estándar MPI a mediados de los 90, que convergió de otras API. Para los multiprocesadores con memoria compartida, un proceso de convergencia similar se observó a finales de los 90, con el surgimiento de pthreads y OpenMP.</li>
								<li>En la actualidad, la computación paralela se ha vuelto mainstream prácticamente, con la llegada de los procesadores de varios núcleos casi por defecto en la mayoría de dispositivos computacionales.</li>
								<li>El software ha sido una parte activa en la evolución de la programación paralela. Los programas paralelos son más difíciles de escribir que los programas secuenciales, ya que se requiere que haya una comunicación y sincronización entre las tareas que se han paralelizado.</li>
							</ul>							
				</div>
			</section>

			<section id="four" class="wrapper">
				<div class="inner">	
					<h2>Ventajas</h2>
					<ul>
						<li>Resuelve problemas que no se podrían realizar en una sola CPU</li>
						<li>Resuelve problemas que no se pueden resolver en un tiempo razonable</li>
						<li>Permite ejecutar problemas de un orden y complejidad mayor</li>
						<li>Permite ejecutar código de manera más rápida (aceleración)</li>
						<li>Permite ejecutar en general más problemas</li>
						<li>Obtención de resultados en menos tiempo</li>
						<li>Permite la ejecución de varias instrucciones en simultáneo</li>
						<li>Permite dividir una tarea en partes independientes</li>
					</ul>

					<h2>Desventajas</h2>
					<ul>
						<li>Mayor consumo de energía</li>
						<li>Mayor dificultad a la hora de escribir programas</li>
						<li>Dificultad para lograr una buena sincronización y comunicación entre las tareas</li>
						<li>Retardos ocasionados por comunicación ente tareas</li>
						<li>Número de componentes usados es directamente proporcional a los fallos potenciales</li>
						<li>Condiciones de carrera</li>
						<ul>
							<li>Múltiples procesos se encuentran en condición de carrera si el resultado de los mismos depende del
								orden de su llegada
							</li>
							<li>Si los procesos que están en condición de carrera no son correctamente sincronizados, puede
								producirse una corrupción de datos
							</li>
						</ul>
					</ul>
				</div>
			</section>

		<!-- Four -->		
			<section id="five" class="wrapper style2 alt">
				<center>
					<h3>Conceptos clave</h3>
					
				</center>
				<div class="inner split">
					<section>
						<ul>
							<li>
								<p>
									<b>Tarea:</b>
									La descomposición de las tareas puede
									ser una tarea complicada, ya que suelen haber varias formas de descomponer el mismo algoritmo.
									Definir las tareas para una aplicación apropiadamente es una del trabajo más difícil en el proceso
									de creación de un programa paralelizable, y difícil de automatizar.
								</p>
							</li>

							<li>
								<p>
									<b>Hilo:</b>
									Un proceso pesado puede convertirse en varios procesos livianos ejecutados de
								manera concurrente. Cada uno de estos procesos se conoce como hilos. Se comunican entre ellos a través de la memoria global

								</p>
							</li>

							<li>
								<p>
									<b>Granularidad:</b>
									El tamaño de cada tarea, en término del número de instrucciones. Cada tarea puede tener un tamaño
									diferente.
								</p>
							</li>

							<li>
								<p>
									<b>Scheduling:</b>
									Las tareas de una aplicación son asignadas a procesos o hilos, que a su vez son asignados a unidades
									de procesamiento. El proceso mediante el cual las tareas son asignadas a los procesos o hilos, y se
									les da un orden de ejecución. Este puede ser especificado en el código, en tiempo de compilación o
									dinámicamente en tiempo de ejecución. El proceso de scheduling debe tener en cuenta la dependencia
									entre tareas, ya que, aunque muchas pueden ser independientes, otras pueden requerir los datos
									producidos por otras tareas.
								</p>
							</li>

							<li>
								<p>
									<b>Mapping:</b>
									Es la asignación de procesos e hilos a unidades de procesamiento, procesadores o núcleos.
									Usualmente el mapping se hace por el sistema en tiempo de ejecución, aunque en ocasiones puede ser
									influenciado por el programador.
								</p>
							</li>
						</ul>	
					</section>
					<section>
						<ul>
							<li>
								<p>
									<b>Sincronización y cooperación:</b>
									Los programas en paralelo necesitan la sincronización y la coordinación de procesos e hilos, para
									que haya una ejecución correcta. Los métodos de coordinación y sincronización en la programación
									paralela están fuertemente asociados a la manera en que los procesos o hilos intercambian
									información, y esto depende de cómo está organizada la memoria en el hardware.
								</p>
							</li>

							<li>
								<p>
									<b>Pipelining:</b>
									Ruptura de una tarea en pasos realizados por diferentes unidades de procesador, con entradas de 
									flujo a través de cada unidad de proceso, Un tipo de computación paralela.
								</p>
							</li>
							
							<li>
								<p>
									<b>Speedup:</b>
									Es un proceso para aumentar el rendimiento entre dos sistemas procesando el mismo problema.
									Es la mejora en la velocidad de ejecución de una tarea ejecutada en dos arquitecturas similares con diferentes recursos.
								</p>
							</li>
			
							<li>									
								<b>Parallel overhead:</b>
								Es la cantidad de tiempo requerido para coordinar tareas paralelas, en lugar de hacer un trabajo útil.
								incluye factores como:
								<ul>
									<li>Tiempo de inicio de la tarea</li>
									<li>Sincronización</li>
									<li>Comunicaciones de datos</li>
									<li>Sobrecarga de software impuesta por lenguajes paralelos, bibliotecas, sistema operativo, etc.</li>
									<li>Tiempo de terminación de la tarea</li>
								</ul>									
							</li>
						</ul>	
					</section>					
				</div>
			</section>	


			<section id="six" class="wrapper style2 alt">		
				<div class="inner">	
					<div class="spotlight">						
						<div class="content">
							<h2>Taxonomia de Flynn</h2>
							<p>
								<h3>Single Instruction, Single Data (SISD)</h3> 
								hay un elemento de procesamiento, que tiene acceso a un único
								programa y a un almacenamiento de datos. En cada paso, el elemento de procesamiento carga una
								instrucción y la
								información correspondiente y ejecuta esta instrucción. El resultado es guardado de vuelta en el
								almacenamiento
								de datos. Luego SISD es el computador secuencial convencional, de acuerdo al modelo de von Neumann.
							</p>
							
						</div>
						<div class="image">
							<img src="images/sisd.png" alt=""  width="140"/>
						</div>
					</div>

					<div class="spotlight">						
						<div class="content">
							<p>
								<h3>Multiple Instruction, Single Data (MISD)</h3> 
								hay múltiples elementos de procesamiento, en el que
								cada
								cual tiene memoria privada del programa, pero se tiene acceso común a una memoria global de
								información.
								En cada paso, cada elemento de procesamiento de obtiene la misma información de la memoria y carga
								una
								instrucción de la memoria privada del programa. Luego, las instrucciones posiblemente diferentes de
								cada
								unidad, son ejecutadas en paralelo, usando la información (idéntica) recibida anteriormente. Este
								modelo
								es muy restrictivo y no se ha usado en ningún computador de tipo comercial.
							</p>
						</div>
						<div class="image">
							<img src="images/misd.png" alt="" />
						</div>
					</div>

					<div class="spotlight">						
						<div class="content">
							<p>
								<h3>Single Instruction, Multiple Data (SIMD): </h3> 
								Hay múltiples elementos de procesamiento, en el
								que	cada cual tiene acceso privado a la memoria de información (compartida o distribuida). Sin embargo,
								hay una sola memoria de programa, desde la cual una unidad de procesamiento especial obtiene y
								despacha instrucciones. En cada paso, cada unidad de procesamiento obtiene la misma instrucción y
								carga desde su memoria privada un elemento de información y ejecuta esta instrucción en dicho
								elemento. Entonces, la instrucción es síncronamente aplicada en paralelo por todos los elementos de
								proceso a diferentes elementos de información. Para aplicaciones con un grado significante de
								paralelismo de información, este acercamiento puede ser muy eficiente. Ejemplos pueden ser
								aplicaciones multimedia y algoritmos de gráficos de computadora.
							</p>
						</div>
						<div class="image">
							<img src="images/simd.png" alt="" />
						</div>
					</div>

					<div class="spotlight">						
						<div class="content">
							<p>
								<h3>Multiple Instruction, Multiple Data (MIMD):</h3> 
								hay múltiples unidades de procesamiento, en la cual
								cada una tiene tanto instrucciones como información separada. Cada elemento ejecuta una instrucción
								distinta en un elemento de información distinto. Los elementos de proceso trabajan asíncronamente.
								Los clusters son ejemplo son ejemplos del modelo MIMD.
							</p>
						</div>
						<div class="image">
							<img src="images/mimd.png" alt="" />
						</div>
					</div>

					
				</div>
			</section>

			<section id="seven" class="wrapper style2 alt">		
				<div class="inner">	
					<div class="spotlight">						
						<div class="content">
							<h2>Arquitecturas de memoria de computación paralela</h2>
							<p>
								<h3>Memoria compartida</h3> 
								<ul>
									<li>Los procesos comparten un espacio de memoria común</li>

									<li>Escriben y leen de manera asíncrona</li>

									<li>No es necesario especificar cómo se comunican los datos entre las tareas</li>

									<li>Se usan semáforos o locks para controlar el acceso a la memoria compartida</li>
								</ul>

								<b> Uniform Memory Access (UMA):</b>
								<ul>
									<li>Lo más comúnmente representado hoy por las máquinas Symmetric Multiprocessor (SMP)</li>

									<li>Procesadores idénticos</li>

									<li>Igual acceso y tiempos de acceso a la memoria</li>

									<li>Si un procesador actualiza una ubicación en memoria compartida, todos los demás procesadores saben sobre la actualización, esto es llamado coherencia del caché</li>
								</ul>
							</div>
							<div class="image">
								<img src="images/uma.gif" alt=""  width="140"/>
							</div>
						</div>
						<div class="spotlight">						
							<div class="content">
								<b> Non-Uniform Memory Access (NUMA)</b>
								<ul>
									<li>Hecho mediante la vinculación física de dos o más SMP</li>

									<li>Un SMP puede acceder directamente a la memoria de otro SMP</li>

									<li>No todos los procesadores tienen igual tiempo de acceso a toda la memoria</li>

									<li>El acceso a la memoria es más lento</li>

									<li>Si se mantiene la coherencia del caché</li>
								</ul>
							</p>
							
						</div>
						<div class="image">
							<img src="images/numa.gif" alt=""  width="140"/>
						</div>
					</div>

					<div class="spotlight">						
						<div class="content">
							<p>
								<h3>Memoria distribuida</h3> 
								<ul>

									<li>También llamado modelo de paso de mensajes</li>

									<li>requieren una red de comunicación para conectar la memoria entre procesadores</li>

									<li>Las tareas intercambian datos por medio del paso y recepción de mensajes</li>

									<li>Los procesadores tienen su propia memoria local. Las direcciones de memoria en un procesador no se asignan a otro procesador, por lo que no hay concepto de espacio de direcciones global en todos los procesadores.</li>

									<li>Debido a que cada procesador tiene su propia memoria local, funciona independientemente. Los cambios que hace en su memoria local no tienen ningún efecto en la memoria de otros procesadores. Por lo tanto, el concepto de coherencia de caché no se aplica.</li>

									<li>Cuando un procesador necesita acceso a los datos de otro procesador, suele ser la tarea del programador definir explícitamente cómo y cuándo se comunican los datos. La sincronización entre tareas también es responsabilidad del programador.</li>

								</ul>
							</p>
						</div>
						<div class="image">
							<img src="images/distributed.gif" alt=""  height="280"/>
						</div>
					</div>

					<div class="spotlight">						
						<div class="content">
							<p>
								<h3>Hibrido memoria distribuida-comopartida</h3> 
								<ul>
									<li>Es la combinación entre memoria compartida y memoria distribuida, con sus ventajas en común.</li>

									<li>Su principal ventaja es su escalabilidad.</li>

									<li>Su principal desventaja es que la complejidad de programación aumenta.</li>
								</ul>
							</p>
						</div>
						<div class="image">
							<img src="images/hybrid.gif" alt="" />
						</div>
					</div>

					<div class="spotlight">						
						<div class="content">
							<p>
								<h3>Hilos</h3> 
								<ul>
									<li>Un proceso pesado puede convertirse en varios procesos livianos ejecutados de manera concurrente.</li>

									<li>Se pueden describir como una subrutina dentro del programa principal.</li>

									<li>Se comunican entre ellos a través de la memoria global. </li>
								</ul>
							</p>
						</div>
						<div class="image">
							<img src="images/threadsModel.gif" alt="" />
						</div>
					</div>
					
					<div class="spotlight">						
						<div class="content">
							<p>
								<h3>Datos en paralelo</h3> 
								<ul>
									<li>También conocido como PGAS (Partitioned Global Address Space)</li>

									<li>Una serie de tareas trabajan de manera colectiva en la misma estructura de datos</li>

									<li>Las tareas realizan la misma operación, pero cada una en su partición pero cada tarea trabaja en una
										partición diferente de ésta </li>
								</ul>
							</p>
						</div>
						<div class="image">
							<img src="images/data_parallel_model.gif" alt="" />
						</div>
					</div>

				</div>
			</section>

			<section id="eight" class="wrapper style2 alt">		
				<div class="inner">	
					<div class="spotlight">	
						<div class="image">
							<img src="images/sync.gif" alt="" />
						</div>					
						<div class="content">
							<h2>Diseño de programas paralelos</h2>
							<p>
								<h3>Sincronización</h3> 
								<ul>
									<li>Administrar la secuencia de trabajo y las tareas que lo realizan es una consideración crítica del diseño para la mayoría de los programas paralelos.</li>

									<li>Puede ser un factor significativo en el desempeño del programa </li>

									<li>A menudo requiere "serialización" de segmentos del programa.</li>
								</ul>
							</p>							
						</div>						
					</div>

					<div class="spotlight">						
						<div class="content">
							<p>
								<h3>Tipos de Sincronización</h3> 
								<b> Barrier</b>
								<ul>
									<li>todas las tareas están involucradas</li>

									<li>Cada tarea realiza su trabajo hasta que alcanza la barrera. Después, se detiene o "bloquea".</li>

									<li>Cuando la última tarea llega a la barrera, todas las tareas se sincronizan.</li>

									<li>Lo que sucede a partir de aquí varía. Algunas veces, una sección del código debe ser ejecutada en serie. En otros casos, las tareas se liberan automáticamente para continuar su trabajo.</li>

									</ul>
							</p>
						</div>
						<div class="image">
							<img src="images/mutex.png" alt="" />
						</div>
					</div>

					<div class="spotlight">						
						<div class="content">
							<p>
								 
								<b> Lock / semaphore</b>
								<ul>
									<li>Puede involucrar cualquier número de tareas</li>

									<li>Se utiliza para serializar el acceso a datos globales o a una sección de código. Sólo una tarea a la vez se puede ejecutar.</li>

									<li>La primera tarea en llegar al lock "lo bloquea". Esta tarea puede acceder de forma segura (en serie) a los datos protegidos o al código.</li>

									<li>Otras tareas pueden intentar adquirir el lock pero deben esperar hasta que la tarea que posee el bloqueo lo libere.</li>

									</ul>
							</p>
						</div>
						<div class="image">
							<img src="images/semaphore.png" alt="" />
						</div>
					</div>

					<div class="spotlight">						
						<div class="content">
							<p>
								 
								<b> Operaciones de comunicación sincronica</b>
								<ul>
									<li>Incluye sólo aquellas tareas que ejecutan una operación de comunicación</li>

									<li>Cuando una tarea realiza una operación de comunicación, se requiere alguna forma de coordinación con las otras tareas que participan en la comunicación. </li>

									<li>Antes de que una tarea pueda realizar una operación de envío, primero debe recibir un aviso  de el receptor sobre si está disponible para enviar.</li>

									<li>Lo que sucede a partir de aquí varía. Algunas veces, una sección del código debe ser ejecutada en serie. En otros casos, las tareas se liberan automáticamente para continuar su trabajo.</li>

									</ul>
							</p>
						</div>
						<div class="image">
							<img src="images/sender.jpg" alt="" />
						</div>
					</div>

			</section>

			<section id="nine" class="wrapper style2 alt">		
				<div class="inner">	
					<div class="spotlight">	
						<div class="image">
							<img src="images/load.jpg" alt="" />
						</div>					
						<div class="content">
							<h2>Balanceador de carga</h2>
							<p>Se refiere a la práctica de distribuir cantidades aproximadamente iguales de trabajo entre las tareas, de modo que todas las tareas se mantengan ocupadas todo el tiempo. Se puede considerar una minimización del tiempo de inactividad de la tarea.</p>
								<ul>
									<li>Asignar el trabajo que recibe cada tarea equitativamente</li>

									<li>Puede ser un factor significativo en el desempeño del programa </li>

									<li>A menudo requiere "serialización" de segmentos del programa.</li>
								</ul>
							</p>							
						</div>						
					</div>
					<div class="spotlight">	
										
						<div class="content">
							<b>asignación de trabajo dinámico</b>
							<p>Ciertas clases de problemas producen desequilibrios de carga incluso si los datos están distribuidos uniformemente entre las tareas</p>
								<ul>
									<li>Cuando la cantidad de trabajo que realiza cada tarea es variable o no se puede predecir, puede ser útil usar un planificador - task pool approach. Cuando cada tarea termina su trabajo, espera en una cola para obtener una nueva pieza de trabajo.</li>

									<li>Puede ser necesario diseñar un algoritmo que detecte y maneje desequilibrios de carga como ocurren dinámicamente dentro del código.</li>
								</ul>
							</p>							
						</div>
						<div class="image">
							<img src="images/balancer.gif" alt="" />
						</div>							
					</div>
				</div>
			</section>
			
			<section id="ten" class="wrapper style2 alt">		
				<div class="inner">
					<div class="spotlight">	
						<div class="content">
							<h2>OpenMP</h2>
							<p>
								Es una interfaz de programa de aplicación (API) que se puede utilizar para dirigir explícitamente paralelismo de memoria compartida multi-procesos. Está compuesto por:
								<ul>
									<li>Directivas de compilación</li>
									<li>Runtime Library Routines</li>
									<li>Variables de entorno</li>
								</ul>
							</p>
							<div class="image">
							<img src="images/openmp.gif" alt="" />
						</div>	
						</div>
							
								
							<b>Estructura general de OpenMP en C++</b>
							<pre >

								<code>
  #include &#60omp.h>
  int main () {
    int var1, var2, var3;
	//Código en serie...     
	   	
	//Comienzo de la región paralela hace fork del conjunto de threads 
	#pragma omp parallel private(var1, var2) shared(var3)
	{
	  //Región paralela ejecutada por todos los threads
	  //otras directivas OpenMP                          
	  //Todos los threads se juntan en el thread master 
	}  
	//Continuación del código...
  }
								</code>
							</pre>
						</div>
					</div>
				</div>
			</section>

			<section id="nine" class="wrapper style2 alt">		
				<div class="inner">
					<div class="spotlight">	
						<div class="content">
							<h3>Ejemplo región paralela</h3>
							<pre >
								<code>
#include &#60omp.h>
#include &#60stdio.h>
int main(int argc, char *argv[])
{
  /* Cada thread tiene una variable id privada (tid) */
  int nthreads, tid;

  #pragma omp parallel private(tid)
  {
    /* Se asigna y se imprime el id de cada thread  */
    tid = omp_get_thread_num();
    printf("Hello World desde el thread = %d\n", tid);
    /* Solo el thread master ejecuta lo siguiente */
    if (tid == 0)
    {
      nthreads = omp_get_num_threads();
      printf("El numero de threads es = %d\n", nthreads);
    }
  }
}
								</code>
							</pre>
						</div>
					<div>
						<ul>
							<li>Un programa "Hello World" simple</li>
							<li>Cada hilo ejecuta todo el código encerrado en la región paralela</li>
							<li>Las rutinas de la biblioteca OpenMP se utilizan para obtener identificadores de subprocesos y número total de subprocesos</li>
							<li>Output:
								<br>World desde el thread = 2 
								<br>Hello World desde el thread = 1
								<br>Hello World desde el thread = 4
								<br>...
								<br>El numero de threads es = x
							</li>
						</ul>
					</div>
					</div>
				</div>
			</section>

			<section id="nine" class="wrapper style2 alt">		
				<div class="inner">
					<div class="spotlight">	
						<div class="content">
							<h3>Parallel For</h3>
							<pre >
								<code>
#include &#60omp.h>
#include &#60stdio.h>

#define N       1000
#define CHUNKSIZE   100

int main(int argc, char *argv[])
{

  int i, chunk;
  float a[N], b[N], c[N];

  for (i=0; i < N; i++)
    a[i] = b[i] = i * 1.0;
  chunk = CHUNKSIZE;

  #pragma omp parallel for \
  shared(a,b,c,chunk) private(i) \
  schedule(static,chunk)

  for (i=0; i < N; i++)
    c[i] = a[i] + b[i];
}
								</code>
							</pre>
						</div>
						<div>
						<ul>
							<b>Programa simple de adición de vectores</b>
							<li>Las matrices A, B, C y la variable N serán compartidas por todos los subprocesos.</li>
							<li>Variable i será privada para cada hilo; Cada hilo tendrá su propia copia única.</li>
							<li>Las iteraciones del bucle "For" se distribuirán dinámicamente en trozos de tamaño "CHUNK".</li>
							<li>Los hilos no se sincronizarán al completar sus trabajos individuales (NOWAIT).</li>
						</ul>
					</div>
					</div>
				</div>
			</section>



			<section id="nine" class="wrapper style2 alt">		
				<div class="inner">
					<div class="spotlight">	
						<div class="content">
							<h3>Sincronización en OpenMP</h3>
							<pre >
								<code>
#include &#60omp.h>
int main(int argc, char *argv[])
{
  int x;
  x = 0;

  #pragma omp parallel shared(x)
  {
    #pragma omp critical
    x = x + 1;
  }
  /* Final de la región paralela */
}
								</code>
							</pre>
						</div>
						<div>
						<ul>
							<b>Sincronización por medio del comando "critical"</b>
							<li>El comando CRITICAL especifica una región de código que debe ser ejecutada por un solo hilo a la vez.</li>
							<li>Si un subproceso está ejecutándose actualmente dentro de una región CRÍTICA y otro subproceso llega a esa región CRÍTICA e intenta ejecutarla, se bloqueará hasta que el primer subproceso salga de esa región CRÍTICA.</li>
							<li>todos los hilos del equipo intentarán ejecutarse en paralelo. Sin embargo, debido a la construcción CRÍTICA que rodea el incremento de x, sólo un hilo podrá leer, incrementar o escribir x en cualquier momento</li>
							
						</ul>
					</div>
					</div>
				</div>
				<ul id="eleven" class="actions special">
						<li><a href="./presentation.pdf" class="button alt">Diapositivas Exposición</a></li>
						<li><a href="./taller.pdf" class="button alt">Taller</a></li>
					</ul>
			</section>


			<section id="twelve" class="wrapper">
				<div class="inner split">
					<h2 id="biblio">Bibliografía</h2>
					<ol>
						<li>
							<a href="http://proparalelaydistribuida.blogdiario.com/tags/lenguajes-paralelos/">http://proparalelaydistribuida.blogdiario.com/tags/lenguajes-paralelos/</a>
						</li>
						<li>
							<a href="http://informatica.uv.es/iiguia/ALP/materiales/1_1_a_ComputacionParalela.pdf">http://informatica.uv.es/iiguia/ALP/materiales/1_1_a_ComputacionParalela.pdf</a>
						</li>
						<li>
							<a href="http://lahuen.dcc.uchile.cl/mm_wiki/lib/exe/fetch.php?media=cpar:1-modelos.pdf">http://lahuen.dcc.uchile.cl/mm_wiki/lib/exe/fetch.php?media=cpar:1-modelos.pdf</a>
						</li>

						<li>
							<a href="http://www.cs.buap.mx/~mtovar/doc/ProgConc/ProgramacionParalela.pdf">http://www.cs.buap.mx/~mtovar/doc/ProgConc/ProgramacionParalela.pdf</a>
						</li>

						<li>
							<a href="http://www.saber.ula.ve/bitstream/123456789/15969/1/com_par.pdf">http://www.saber.ula.ve/bitstream/123456789/15969/1/com_par.pdf</a>
						</li>

						<li>
							<a href="https://computing.llnl.gov/tutorials/parallel_comp/">https://computing.llnl.gov/tutorials/parallel_comp/</a>
						</li>

						<li>
							<a href="http://lsi.ugr.es/jmantas/pdp/tutoriales/tutorial_mpi.php?tuto=03_pi">http://lsi.ugr.es/jmantas/pdp/tutoriales/tutorial_mpi.php?tuto=03_pi</a>
						</li>

						<li>
							Rauber, T., & Runger, G. (n.d.). Parallel programming: For multicore and cluster systems. Springer
							Books.
						</li>

						<li>
							Intro to parallel programming. <a
								href="https://www.udacity.com/course/intro-to-parallel-programming--cs344">Udacity course</a>.
						</li>
					</ol>
    
				</div>
			</section>

		<!-- Footer -->
			<footer id="footer">
				<div class="copyright">
					Autores: Fabián Bernal, Camilo Albarracín, Juan Gaona, Luis Giraldo
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/skel.min.js"></script>
			<script src="assets/js/util.js"></script>
			<!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]-->
			<script src="assets/js/main.js"></script>

	</body>
</html>